// Generated by CoffeeScript 1.6.1
(function() {
  var attributeRe, exports, requireBackboneEvents, requireEventEmitter, _,
    __hasProp = {}.hasOwnProperty,
    __slice = [].slice;

  if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
    exports = module.exports;
    _ = require('underscore');
    requireEventEmitter = function() {
      return require('events').EventEmitter;
    };
    requireBackboneEvents = function() {
      return require('backbone').Events;
    };
  } else {
    exports = window;
    _ = window._ || require('underscore');
    requireEventEmitter = function() {
      return window.EventEmitter || require('events').EventEmitter;
    };
    requireBackboneEvents = function() {
      var _ref;
      return ((_ref = global.Backbone) != null ? _ref.Events : void 0) || require('backbone').Events;
    };
  }

  attributeRe = /^_/;

  exports.Model = function(klass) {
    var proto;
    if (klass == null) {
      klass = exports.BaseClass();
    }
    proto = klass.prototype;
    proto.isModel = true;
    proto.initialize = function(attrs, options) {
      if (this.defaults) {
        this.set(this.defaults, options);
      }
      if (attrs) {
        this.set(attrs, options);
      }
      return this;
    };
    proto.isEqual = function(other) {
      var name, otherSize, size, value;
      if (this === other) {
        return true;
      }
      if (!(other && this.id === other.id && other.isModel)) {
        return false;
      }
      size = 0;
      for (name in this) {
        if (!__hasProp.call(this, name)) continue;
        value = this[name];
        if (!(!attributeRe.test(name))) {
          continue;
        }
        size += 1;
        if (!_.isEqual(value, other[name])) {
          return false;
        }
      }
      otherSize = 0;
      for (name in other) {
        if (!__hasProp.call(other, name)) continue;
        if (!attributeRe.test(name)) {
          otherSize += 1;
        }
      }
      return size === otherSize;
    };
    proto.set = function(attrs, options) {
      var changes, name, newValue, oldValue;
      if (attrs == null) {
        return {};
      }
      changes = {};
      for (name in attrs) {
        if (!__hasProp.call(attrs, name)) continue;
        newValue = attrs[name];
        if (!(!attributeRe.test(name))) {
          continue;
        }
        oldValue = this[name];
        if (!_.isEqual(oldValue, newValue)) {
          changes[name] = oldValue;
        }
        this[name] = newValue;
      }
      return changes;
    };
    proto.clone = function() {
      return new this.constructor(this.attributes());
    };
    proto.clear = function(options) {
      var changes, name;
      changes = attributes();
      for (name in this) {
        if (!__hasProp.call(this, name)) continue;
        delete this[name];
      }
      return changes;
    };
    proto.validate = function() {
      var errors, msg, name, validator, _ref, _ref1;
      if (!this.validations) {
        return null;
      }
      errors = {};
      _ref = this.validations;
      for (name in _ref) {
        if (!__hasProp.call(_ref, name)) continue;
        validator = _ref[name];
        if (msg = validator(this[name])) {
          ((_ref1 = errors[name]) != null ? _ref1 : errors[name] = []).push(msg);
        }
      }
      if (_.isEmpty(errors)) {
        return null;
      } else {
        return errors;
      }
    };
    proto.isValid = function() {
      return this.validate() == null;
    };
    proto.attributes = function() {
      var attrs, name, value;
      attrs = {};
      for (name in this) {
        if (!__hasProp.call(this, name)) continue;
        value = this[name];
        if (!attributeRe.test(name)) {
          attrs[name] = value;
        }
      }
      return attrs;
    };
    proto.toJSON = function() {
      return this.attributes();
    };
    proto.inspect = function() {
      return JSON.stringify(this.toJSON());
    };
    proto.toString = function() {
      return this.inspect();
    };
    proto.cid = function() {
      return this._cid = _.uniqueId();
    };
    return klass;
  };

  exports.Model.Events = function(klass, type) {
    var proto;
    exports.Events(klass, type);
    proto = klass.prototype;
    proto.setWithoutEvents = proto.set;
    proto.set = function(attrs, options) {
      var changes;
      changes = this.setWithoutEvents(attrs, options);
      this._emitChanges(changes, options);
      return changes;
    };
    proto.clearWithoutEvents = proto.clear;
    proto.clear = function(options) {
      var changes;
      changes = this.clearWithoutEvents(options);
      this._emitChanges(changes, options);
      return changes;
    };
    proto._emitChanges = function(changes, options) {
      var name, oldValue;
      if (!(_.isEmpty(changes) && !(options != null ? options.silent : void 0))) {
        for (name in changes) {
          oldValue = changes[name];
          this.trigger("change:" + name, this, oldValue);
        }
        return this.trigger('change', this, changes);
      }
    };
    return klass;
  };

  exports.Collection = function(klass) {
    var method, proto, underscoreMethods, underscoreMethodsReturningCollection, _fn, _fn1, _i, _j, _len, _len1;
    if (klass == null) {
      klass = exports.BaseClass();
    }
    proto = klass.prototype;
    proto.isCollection = true;
    proto.initialize = function() {
      var args, _ref;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      _ref = [[], 0, {}], this.models = _ref[0], this.length = _ref[1], this.ids = _ref[2];
      this.add.apply(this, args);
      return this;
    };
    proto.add = function() {
      var args, models, options, _ref;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      _ref = _.isArray(args[0]) ? args : [args, {}], models = _ref[0], options = _ref[1];
      if (options == null) {
        options = {};
      }
      return this._add(models, options);
    };
    proto._add = function(models, options) {
      var added, model, _i, _len;
      added = [];
      for (_i = 0, _len = models.length; _i < _len; _i++) {
        model = models[_i];
        if (!model.isModel) {
          klass = this.model || (function() {
            throw new Error("no Model for Collection (" + this + ")!");
          }).call(this);
          model = new klass(model);
        }
        if (model.id == null) {
          throw new Error("no id for Model (" + model + ")!");
        }
        if (model.id in this.ids) {
          continue;
        }
        this.ids[model.id] = this.models.length;
        this.models.push(model);
        added.push(model);
      }
      this.length = this.models.length;
      return added;
    };
    proto["delete"] = function() {
      var args, models, options, _ref;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      _ref = _.isArray(args[0]) ? args : [args, {}], models = _ref[0], options = _ref[1];
      if (options == null) {
        options = {};
      }
      return this._delete(models, options);
    };
    proto.del = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this["delete"].apply(this, args);
    };
    proto._delete = function(models, options) {
      var deleted, deletedIndexes, index, model, oldModels, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
      _ref = [[], {}], deleted = _ref[0], deletedIndexes = _ref[1];
      for (_i = 0, _len = models.length; _i < _len; _i++) {
        model = models[_i];
        if (!(model.id in this.ids)) {
          continue;
        }
        deleted.push(model);
        deletedIndexes[this.ids[model.id]] = true;
      }
      if (!_.isEmpty(deletedIndexes)) {
        oldModels = this.models;
        _ref1 = [[], {}], this.models = _ref1[0], this.ids = _ref1[1];
        for (index = _j = 0, _len1 = oldModels.length; _j < _len1; index = ++_j) {
          model = oldModels[index];
          if (!(index in deletedIndexes)) {
            this.models.push(model);
          }
        }
        _ref2 = this.models;
        for (index = _k = 0, _len2 = _ref2.length; _k < _len2; index = ++_k) {
          model = _ref2[index];
          this.ids[model.id] = index;
        }
      }
      this.length = this.models.length;
      return deleted;
    };
    proto.get = function(id) {
      var index;
      if ((index = this.ids[id]) != null) {
        return this.models[index];
      }
    };
    proto.has = function(id) {
      return id in this.ids;
    };
    proto.at = function(index) {
      return this.models[index];
    };
    proto.clear = function(options) {
      var deleted, _ref;
      if (options == null) {
        options = {};
      }
      deleted = this.models;
      _ref = [[], 0, {}], this.models = _ref[0], this.length = _ref[1], this.ids = _ref[2];
      return deleted;
    };
    proto.inspect = function() {
      return JSON.stringify(this.toJSON());
    };
    proto.toString = function() {
      return this.inspect();
    };
    proto.toJSON = function() {
      return this.models;
    };
    proto.isEqual = function(other) {
      var index, model, _i, _len, _ref;
      if (this === other) {
        return true;
      }
      if (!(other && other.length === this.length && other.isCollection)) {
        return false;
      }
      _ref = this.models;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        model = _ref[index];
        if (!model.isEqual(other.at(index))) {
          return false;
        }
      }
      return true;
    };
    underscoreMethodsReturningCollection = ['forEach', 'each', 'map', 'filter', 'select', 'reject', 'every', 'all', 'some', 'any', 'sortBy', 'toArray', 'rest', 'without', 'shuffle'];
    _fn = function(method) {
      return proto[method] = function() {
        var list, _ref;
        list = (_ref = _[method]).apply.apply(_ref, [_, this.models].concat(__slice.call(arguments)));
        return new this.constructor(list);
      };
    };
    for (_i = 0, _len = underscoreMethodsReturningCollection.length; _i < _len; _i++) {
      method = underscoreMethodsReturningCollection[_i];
      _fn(method);
    }
    underscoreMethods = ['reduce', 'reduceRight', 'find', 'detect', 'include', 'contains', 'invoke', 'max', 'min', 'sortedIndex', 'size', 'first', 'initial', 'last', 'indexOf', 'lastIndexOf', 'isEmpty', 'groupBy', 'countBy'];
    _fn1 = function(method) {
      return proto[method] = function() {
        var _ref;
        return (_ref = _[method]).apply.apply(_ref, [_, this.models].concat(__slice.call(arguments)));
      };
    };
    for (_j = 0, _len1 = underscoreMethods.length; _j < _len1; _j++) {
      method = underscoreMethods[_j];
      _fn1(method);
    }
    return klass;
  };

  exports.Collection.Sorted = function(klass) {
    var proto;
    proto = klass.prototype;
    proto.isSortedCollection = true;
    if (proto.hasEvents) {
      throw new Error("Sorted mixin should be applied before Events!");
    }
    proto.sort = function(options) {
      return this._sort(options);
    };
    proto._sort = function(options) {
      var changed, index, model, _i, _len, _ref;
      if ((options != null ? options.comparator : void 0) != null) {
        this.comparator = options.comparator;
      }
      if (!this.comparator) {
        return false;
      }
      if (this.comparator.length === 1) {
        this.models = _(this.models).sortBy(this.comparator);
      } else {
        this.models.sort(this.comparator);
      }
      changed = false;
      _ref = this.models;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        model = _ref[index];
        if (this.ids[model.id] !== index) {
          changed = true;
        }
        this.ids[model.id] = index;
      }
      return changed;
    };
    proto._addWithoutSort = proto._add;
    proto._add = function(models, options) {
      var added;
      added = this._addWithoutSort(models, options);
      if (added.length > 0) {
        this._sort(options);
      } else if ((options != null ? options.comparator : void 0) != null) {
        this.comparator = options.comparator;
      }
      return added;
    };
    return klass;
  };

  exports.Collection.Events = function(klass, type) {
    var proto;
    exports.Events(klass, type);
    proto = klass.prototype;
    proto.initializeWithoutEvents = proto.initialize;
    proto.initialize = function() {
      var args,
        _this = this;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this._forwardModelChangeEvent = function(model, changes) {
        return _this.trigger('model:change', model, changes, _this);
      };
      return this.initializeWithoutEvents.apply(this, args);
    };
    if (proto.sort != null) {
      proto.sortWithoutEvents = proto.sort;
      proto.sort = function(options) {
        var changed;
        changed = this.sortWithoutEvents(options);
        if (changed && !(options != null ? options.silent : void 0)) {
          this.trigger('change', this);
        }
        return changed;
      };
    }
    proto._addWithoutEvents = proto._add;
    proto._add = function(models, options) {
      var added;
      added = this._addWithoutEvents(models, options);
      this._emitAddChanges(added, options);
      return added;
    };
    proto._deleteWithoutEvents = proto._delete;
    proto._delete = function(models, options) {
      var deleted;
      deleted = this._deleteWithoutEvents(models, options);
      this._emitDeleteChanges(deleted, options);
      return deleted;
    };
    proto.clearWithoutEvents = proto._delete;
    proto.clear = function(options) {
      var deleted;
      deleted = this.clearWithoutEvents(options);
      this._emitDeleteChanges(deleted, options);
      return deleted;
    };
    proto._emitAddChanges = function(added, options) {
      var model, _i, _j, _len, _len1;
      for (_i = 0, _len = added.length; _i < _len; _i++) {
        model = added[_i];
        if (model.hasEvents) {
          model.on('change', this._forwardModelChangeEvent);
        }
      }
      if ((added.length > 0) && !(options != null ? options.silent : void 0)) {
        for (_j = 0, _len1 = added.length; _j < _len1; _j++) {
          model = added[_j];
          this.trigger('add', model, this);
        }
        return this.trigger('change', this);
      }
    };
    proto._emitDeleteChanges = function(deleted, options) {
      var model, _i, _j, _len, _len1;
      for (_i = 0, _len = deleted.length; _i < _len; _i++) {
        model = deleted[_i];
        if (model.hasEvents) {
          model.off('change', this._forwardModelChangeEvent);
        }
      }
      if ((deleted.length > 0) && !(options != null ? options.silent : void 0)) {
        for (_j = 0, _len1 = deleted.length; _j < _len1; _j++) {
          model = deleted[_j];
          this.trigger('delete', model, this);
        }
        return this.trigger('change', this);
      }
    };
    return klass;
  };

  exports.Events = function(klass, type) {
    var EventEmitter, initializeWithoutEventEmitter, proto;
    if (type == null) {
      type = 'EventEmitter';
    }
    proto = klass.prototype;
    proto.hasEvents = true;
    if (type === 'EventEmitter') {
      EventEmitter = requireEventEmitter();
      _(proto).extend(EventEmitter.prototype);
      initializeWithoutEventEmitter = proto.initialize;
      proto.initialize = function() {
        EventEmitter.apply(this);
        return initializeWithoutEventEmitter.apply(this, arguments);
      };
      proto.on = function() {
        return this.addListener.apply(this, arguments);
      };
      proto.off = function() {
        return this.removeListener.apply(this, arguments);
      };
      proto.trigger = function() {
        return this.emit.apply(this, arguments);
      };
    } else if (type === 'Backbone.Events') {
      _(proto).extend(requireBackboneEvents());
    } else {
      throw new Error("unknown type " + type);
    }
    return klass;
  };

  exports.BaseClass = function() {
    return function() {
      var _ref;
      if ((_ref = this.initialize) != null) {
        _ref.apply(this, arguments);
      }
      return this;
    };
  };

  exports.BaseModel = exports.Model();

  exports.BaseCollection = exports.Collection();

  exports.FullModel = exports.Model.Events(exports.Model());

  exports.FullCollection = exports.Collection.Events(exports.Collection.Sorted(exports.Collection()));

}).call(this);
